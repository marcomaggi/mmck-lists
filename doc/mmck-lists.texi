\input texinfo.tex
@c %**start of header
@setfilename mmck-lists.info
@settitle @sc{mmck} Lists
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Lists handling for @sc{chicken}

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    @sc{mmck} Lists

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmck-lists

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2019

@set CHICKEN_VERSION            5.1.0

@c ------------------------------------------------------------

@set PackageStem                lists

@set PackageAutoconfPrefix      MMCK_LISTS
@set PackagePkgconfigModule     mmck-lists

@set GithubUrl                  @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl                @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl           @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@macro mmck{}
@sc{mmck}
@end macro

@macro chicken{}
@sc{chicken}
@end macro

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a @chicken{} language package
implementing a lists handling library.  @chicken{} is a Scheme--to--C compiler supporting the
language features as defined in the ``Revised^5 Report on Scheme''.

The library supports @posix{} platforms.  This package has been tested with @chicken{} version
@value{CHICKEN_VERSION}.

This package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmck-lists: (mmck-lists).     A lists handling library for @chicken{}.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* unsafe::                      Basic unsafe list operations.
* cons::                        List constructors.
* pred::                        List predicates.
* getters::                     Special list getters.
* fold::                        Folding lists.
* map::                         Mapping lists.
* search::                      Searching lists.
* conditions::                  Exceptional-condition object-types.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


@cindex @library{mmck lists}, library
@cindex Library @library{mmck lists}


This document describes version @value{VERSION} of @value{PACKAGE}, a @chicken{} language package
implementing a lists handling library.  @chicken{} is a Scheme-to-C compiler supporting the language
features as defined in the ``Revised^5 Report on Scheme''.

This package supports @posix{} platforms.  The package depends upon the @chicken{} eggs:
@code{matchable}.  This package depends upon the external packages: @mmck{} Lang; @mmck{}
Exceptional Conditions.  To run the tests distributed with the source code: this package depends
upon the package @mmck{} Checks.

The package installs the library @library{mmck lists} along with its import library.  To require
the library and import its syntactic bindings in a module we can do:

@example
(declare (unit my-module)
         (emit-import-library my-module))

(require-library (mmck lists))

(module (my-module)
    ()
  (import (scheme)
          (mmck lists))

  ...

  #| end of module |# )
@end example

The core @api{} implemented by @value{PACKAGE} is inspired by that defined by @rnrs{6}; but there
are important differences.  Notice that:

@itemize
@item
The functions @strong{do not} check for circular lists.  If a list argument is circular: the
behaviour is undefined.

@item
The functions check their list arguments at the beginning, traversing the whole lists.  This
consumes resources.
@end itemize

@c page
@node version
@chapter Version functions


@value{PACKAGE}'s version number follows the specification of @dfn{Semantic Versioning} version 2.0
as outlined at:

@center @url{https://semver.org/}

@noindent
the following functions are available to inspect the version specification at runtime.


@defun mmck-@value{PackageStem}-package-major-version
Return a fixnum representing the package's major version number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the major version number is the fixnum @samp{1}.
@end defun


@defun mmck-@value{PackageStem}-package-minor-version
Return a fixnum representing the package's minor version number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the minor version number is the fixnum @samp{2}.
@end defun


@defun mmck-@value{PackageStem}-package-patch-level
Return a fixnum representing the package's patch level number.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the patch level number is the fixnum @samp{3}.
@end defun


@defun mmck-@value{PackageStem}-package-prerelease-tag
Return a string representing the package's prerelease tag.  As example, if the full semantic version
is @samp{1.2.3-devel.0+x86-64}: the prerelease tag is the string @samp{"devel.0"}.  This string may
be empty.
@end defun


@defun mmck-@value{PackageStem}-package-build-metadata
Return a string representing the package's build metadata.  As example, if the full semantic version
is @samp{1.2.3-devel.0+x86-64}: the build metadata is the string @samp{"x86-64"}.  This string may
be empty.  We need to remember that this specification segment must contain only @ascii{}
alphanumerics and hyphen @samp{[0-9A-Za-z-]}; underscores are @strong{not} allowed.
@end defun


@defun mmck-@value{PackageStem}-package-version
Return a string representing the package's version.  As example, if the full semantic version is
@samp{1.2.3-devel.0+x86-64}: the package version is the string @samp{"1.2.3-devel.0"}, without the
build metadata.
@end defun


@defun mmck-@value{PackageStem}-package-semantic-version
Return a string representing the package's semantic version.  As example, if the full semantic
version is @samp{1.2.3-devel.0+x86-64}: the package version is the string
@samp{"v1.2.3-devel.0+x86-64"}, notice the leading character @samp{v}.
@end defun

@c page
@node unsafe
@chapter Basic unsafe list operations


@deffn {Unsafe Operation} $car @var{pair}
Like @func{car} but the operation is integrated at the call site and it does not check its
arguments.
@end deffn


@deffn {Unsafe Operation} $cdr @var{pair}
Like @func{cdr} but the operation is integrated at the call site and it does not check its
arguments.
@end deffn


@deffn {Unsafe Operation} $set-car! @var{pair} @var{new-value}
Like @func{set-car!} but the operation is integrated at the call site and it does not check its
arguments.
@end deffn


@deffn {Unsafe Operation} $set-cdr! @var{pair} @var{new-value}
Like @func{set-cdr!} but the operation is integrated at the call site and it does not check its
arguments.
@end deffn


@deffn {Unsafe Operation} $set-car-immediate! @var{pair} @var{new-value}
Like @func{set-car!} but the operation is integrated at the call site, it does not check its
arguments, and @var{new-value} must be an immediate value.
@end deffn


@deffn {Unsafe Operation} $set-cdr-immediate! @var{pair} @var{new-value}
Like @func{set-cdr!} but the operation is integrated at the call site, it does not check its
arguments, and @var{new-value} must be an immediate value.
@end deffn

@c page
@node cons
@chapter List constructors


@defun cons* @var{obj} @dots{} @var{tail}
Build and return a new list having the @var{obj} as first values and @var{tail} as tail.

@lisp
(cons* 1 '())           @result{} (1)
(cons* 1 2 '())         @result{} (1 2)
(cons* 1 2 3 '())       @result{} (1 2 3)

(cons* 1 '(2 3))        @result{} (1 2 3)
(cons* 1 2 3 '(4 5))    @result{} (1 2 3 4 5)
@end lisp
@end defun


@defun make-list @var{len}
@defunx make-list @var{len} @var{fill}
Build and return a new list of @var{len} pairs.  If @var{fill} is given: the cars of the pairs are
set to @var{fill}; @var{fill} defaults to the return value of @code{(void)}, where @func{void} is
the syntactic binding exported by @library{chicken base}.

@lisp
(make-list 0 'a)        @result{} ()
(make-list 3 'a)        @result{} (a a a)

(equal? (make-list 3)
        (list (void) (void) (void)))
@result{} #t
@end lisp
@end defun

@c page
@node pred
@chapter List predicates


@defun list-of-lists? @var{obj}
Return @true{} if @var{obj} is a (possibly empty) list of (possibly empty) lists; otherwise return
@false{}.  Notice that this function returns null if @var{obj} is neither null nor a proper list of
pairs.

@lisp
(list-of-lists? '())            @result{} #t
(list-of-lists? '(()))          @result{} #t
(list-of-lists? '(() ()))       @result{} #t
(list-of-lists? '(() () ()))    @result{} #t
(list-of-lists? '((1)))         @result{} #t
(list-of-lists? '((1) (2)))     @result{} #t
(list-of-lists? '((1) (2) (3))) @result{} #t

(list-of-lists? '(1 (2) (3)))   @result{} #f
(list-of-lists? '((1) 2 (3)))   @result{} #f
(list-of-lists? '((1) (2) 3))   @result{} #f

(list-of-lists? '#())           @result{} #f
@end lisp
@end defun


@defun list-of-nulls? @var{obj}
Return @true{} if @var{obj} is a (possibly empty) list of null objects; otherwise return @false{}.
Notice that this function returns @false{} if @var{obj} is neither null nor a proper list of nulls.

@lisp
(list-of-nulls? '())            @result{} #t
(list-of-nulls? '(()))          @result{} #t
(list-of-nulls? '(() ()))       @result{} #t
(list-of-nulls? '(() () ()))    @result{} #t

(list-of-nulls? '((1)))         @result{} #f
(list-of-nulls? '((1) (2)))     @result{} #f
(list-of-nulls? '((1) (2) (3))) @result{} #f

(list-of-nulls? '(1 (2) (3)))   @result{} #f
(list-of-nulls? '((1) 2 (3)))   @result{} #f
(list-of-nulls? '((1) (2) 3))   @result{} #f

(list-of-nulls? '#())           @result{} #f
@end lisp
@end defun


@defun list-of-pairs? @var{obj}
Return @true{} if @var{obj} is a (possibly empty) list of pair objects; otherwise return @false{}.
Notice that this function returns @false{} if @var{obj} is neither null nor a proper list of pairs.

@lisp
(list-of-pairs? '())            @result{} #t
(list-of-pairs? '((1)))         @result{} #t
(list-of-pairs? '((1) (2)))     @result{} #t
(list-of-pairs? '((1) (2) (3))) @result{} #t

(list-of-pairs? '(()))          @result{} #f
(list-of-pairs? '(() ()))       @result{} #f
(list-of-pairs? '(() () ()))    @result{} #f

(list-of-pairs? '(1 (2) (3)))   @result{} #f
(list-of-pairs? '((1) 2 (3)))   @result{} #f
(list-of-pairs? '((1) (2) 3))   @result{} #f

(list-of-pairs? '#())           @result{} #f
@end lisp
@end defun


@defun lists-of-lists-of-equal-length? @var{obj}
Return @true{} if @var{obj} is a (possibly empty) list of (possibly empty) lists of equal length;
otherwise return @false{}.  Notice that this function returns @false{} if @var{obj} is neither null
nor a proper list of pairs.

@lisp
(lists-of-lists-of-equal-length? '())                   @result{} #t
(lists-of-lists-of-equal-length? '(()))                 @result{} #t
(lists-of-lists-of-equal-length? '(() ()))              @result{} #t
(lists-of-lists-of-equal-length? '(() () ()))           @result{} #t
(lists-of-lists-of-equal-length? '((1)))                @result{} #t
(lists-of-lists-of-equal-length? '((1) (2)))            @result{} #t
(lists-of-lists-of-equal-length? '((1) (2) (3)))        @result{} #t

(lists-of-lists-of-equal-length? '(() (2) (3)))         @result{} #f
(lists-of-lists-of-equal-length? '((1) () (3)))         @result{} #f
(lists-of-lists-of-equal-length? '((1) (2) ()))         @result{} #f
(lists-of-lists-of-equal-length? '((1 0) (2) (3)))      @result{} #f
(lists-of-lists-of-equal-length? '((1) (2 0) (3)))      @result{} #f
(lists-of-lists-of-equal-length? '((1) (2) (3 0)))      @result{} #f

(lists-of-lists-of-equal-length? '((1 2 3 4 5)))        @result{} #t
(lists-of-lists-of-equal-length? '((1 2 3 4 5)
                                   (6 7 8 9 0)))        @result{} #t
(lists-of-lists-of-equal-length? '((1 2 3 4 5)
                                   (6 7 8 9 0)
                                   (9 8 7 6 5)))        @result{} #t

(lists-of-lists-of-equal-length? 123)                   @result{} #f
@end lisp
@end defun


@defun lists-of-equal-length? @varo{obj} @var{obj} @dots{}
Return @true{} if all the arguments are (possibly empty) lists of equal length; otherwise return
@false{}.  Notice that this function returns @false{} if one of the arguments is neither null nor a
proper list of pairs.

@lisp
(lists-of-equal-length? '())                    @result{} #t
(lists-of-equal-length? '() '())                @result{} #t
(lists-of-equal-length? '() '() '())            @result{} #t
(lists-of-equal-length? '(1))                   @result{} #t
(lists-of-equal-length? '(1) '(2))              @result{} #t
(lists-of-equal-length? '(1) '(2) '(3))         @result{} #t

(lists-of-equal-length? '() '(2) '(3))          @result{} #f
(lists-of-equal-length? '(1) '() '(3))          @result{} #f
(lists-of-equal-length? '(1) '(2) '())          @result{} #f
(lists-of-equal-length? '(1 0) '(2) '(3))       @result{} #f
(lists-of-equal-length? '(1) '(2 0) '(3))       @result{} #f
(lists-of-equal-length? '(1) '(2) '(3 0))       @result{} #f

(lists-of-equal-length? '(1 2 3 4 5))           @result{} #t
(lists-of-equal-length? '(1 2 3 4 5)
                        '(6 7 8 9 0))           @result{} #t
(lists-of-equal-length? '(1 2 3 4 5)
                        '(6 7 8 9 0)
                        '(9 8 7 6 5))           @result{} #t

(lists-of-equal-length? 123)                    @result{} #f
@end lisp
@end defun

@c page
@node getters
@chapter Special list getters


@defun cars-and-cdrs @var{list-of-lists}
@defunx cars-and-cdrs @var{list-of-lists} @var{cars-tail}
The argument @var{list-of-lists} must be a non--empty list of non--empty lists.  Return two values:

@enumerate
@item
A list of the CARs of the lists in @var{list-of-lists}.

@item
A list of the CDRs of the lists in @var{list-of-lists}.
@end enumerate

The optional argument @var{cars-tail} is appended to the cars list; it defaults to null.

@lisp
(cars-and-cdrs '((1 2 3)
                 (4 5 6)))
@result{} (1 4) ((2 3) (5 6))

(cars-and-cdrs '((1 2 3)
                 (4 5 6)
                 (7 8 9)))
@result{} (1 4 7) ((2 3) (5 6) (8 9))

(cars-and-cdrs '((1 2 3)
                 (4 5 6))
               '(a b))
@result{} (1 4 a b) ((2 3) (5 6))

(cars-and-cdrs '((1 2 3)
                 (4 5 6)
                 (7 8 9))
               '(a b))
@result{} (1 4 7 a b) ((2 3) (5 6) (8 9))
@end lisp
@end defun



@defun gather-cars-in-reverse @var{list-of-lists}
@defunx gather-cars-in-reverse @var{list-of-lists} @var{cars-tail}
The argument @var{list-of-lists} must be a (possibly empty) list of (possibly empty) lists.  Return
a list of lists, each sublist being the lists of cars built by iterating through @var{list-of-lists}
from the end.  The optional argument @var{cars-tail} is appended to each cars list; it defaults to
null.

The returned value is the list of lists we would need to implement @func{fold-right}.

@lisp
(gather-cars-in-reverse '())            @result{} ()
(gather-cars-in-reverse '(()))          @result{} ()
(gather-cars-in-reverse '(() ()))       @result{} ()
(gather-cars-in-reverse '(() () ()))    @result{} ()
(gather-cars-in-reverse '((1) (4) (7))) @result{} ((1 4 7))

(gather-cars-in-reverse '((1 2 3)
                          (4 5 6)
                          (7 8 9)))
@result{} ((3 6 9)
    (2 5 8)
    (1 4 7))

(define tail '(a b))

(gather-cars-in-reverse '()            tail) @result{} ()
(gather-cars-in-reverse '(())          tail) @result{} ()
(gather-cars-in-reverse '(() ())       tail) @result{} ()
(gather-cars-in-reverse '(() () ())    tail) @result{} ()
(gather-cars-in-reverse '((1) (4) (7)) tail) @result{} ((1 4 7 a b))

(gather-cars-in-reverse '((1 2 3)
                          (4 5 6)
                          (7 8 9))
                        tail)
@result{} ((3 6 9 a b)
    (2 5 8 a b)
    (1 4 7 a b))
@end lisp
@end defun


@defun butlast-and-last @var{ell}
The argument @var{ell} must be a (possibly empty) proper list.  Return two values:

@enumerate
@item
The list of all the items in @var{ell} but the last.

@item
The last item in @var{ell}.
@end enumerate

@lisp
(butlast-and-last '())               @error{} &list-is-empty
(butlast-and-last '(0))              @result{} () 0
(butlast-and-last '(0 1))            @result{} (0) 1
(butlast-and-last '(0 1 2))          @result{} (0 1) 2
(butlast-and-last '(0 1 2 3))        @result{} (0 1 2) 3
(butlast-and-last '(0 1 2 3 4))      @result{} (0 1 2 3) 4
(butlast-and-last '(0 1 2 3 4 5))    @result{} (0 1 2 3 4) 5
(butlast-and-last '(0 1 2 3 4 5 6))  @result{} (0 1 2 3 4 5) 6
@end lisp
@end defun

@c page
@node fold
@chapter Folding lists


@defun fold-left @var{combine} @var{nil} @vari{list} @varii{list} @dots{} @varn{list}
The @var{list}s must all have the same length.  @var{combine} must be a procedure; it must accept
one more argument than there are @var{list}s and return a single value; it must not mutate the
@var{list} arguments.

The @func{fold-left} procedure iterates the @var{combine} procedure over an accumulator value and
the elements of the @var{list}s from left to right, starting with an accumulator value of @var{nil}.
@var{combine} must have signature:

@lisp
(lambda (nil item0 item ...) . @meta{body})
@end lisp

More specifically, @func{fold-left} returns @var{nil} if the @var{list}s are empty.  If they are not
empty, @var{combine} is first applied to @var{nil} and the respective first elements of the
@var{list}s in order.  The result becomes the new accumulator value, and @var{combine} is applied to
the new accumulator value and the respective next elements of the @var{list}.  This step is repeated
until the end of the list is reached; then the accumulator value is returned.

@var{combine} is always called in the same dynamic environment as @func{fold-left} itself.

@lisp
(fold-left + 0 '(1 2 3 4 5))
@result{} 15

(fold-left
    (lambda (a e)
      (cons e a))
  '()
  '(1 2 3 4 5))
@result{} (5 4 3 2 1)

(fold-left
    (lambda (count x)
      (if (odd? x)
          (+ count 1)
        count))
  0
  '(3 1 4 1 5 9 2 6 5 3))
@result{} 7

(fold-left
    (lambda (max-len s)
      (max max-len (string-length s)))
  0
  '("longest" "long" "longer"))
@result{} 7

(fold-left cons '(q) '(a b c))
@result{} ((((q) . a) . b) . c)

(fold-left + 0 '(1 2 3) '(4 5 6))
@result{} 21
@end lisp
@end defun


@defun fold-right @var{combine} @var{nil} @vari{list} @varii{list} @dots{} @varn{list}
The @var{list}s must all have the same length.  @var{combine} must be a procedure; it must accept
one more argument than there are @var{list}s and return a single value; @var{combine} must not
mutate the @var{list} arguments.

The @func{fold-right} procedure iterates the @var{combine} procedure over the elements of the
@var{list}s from right to left and an accumulator value, starting with an accumulator value of
@var{nil}; @var{combine} must have signature:

@lisp
(lambda (item0 item ... nil) . @meta{body})
@end lisp

More specifically, @func{fold-right} returns @var{nil} if the @var{list}s are empty.  If they are
not empty, @var{combine} is first applied to the respective last elements of the @var{list}s in
order and @var{nil}.  The result becomes the new accumulator value, and @var{combine} is applied to
the respective previous elements of the @var{list}s and the new accumulator value.  This step is
repeated until the beginning of the list is reached; then the accumulator value is returned.

@var{proc} is always called in the same dynamic environment as @func{fold-right} itself.

@lisp
(fold-right + 0 '(1 2 3 4 5))
@result{} 15

(fold-right cons '() '(1 2 3 4 5))
@result{} (1 2 3 4 5)

(fold-right
    (lambda (item knil)
      (cons item knil))
  '()
  '(1 2 3 4))
@result{} (1 2 3 4)

(fold-right
    (lambda (x l)
      (if (odd? x) (cons x l) l))
  '()
  '(3 1 4 1 5 9 2 6 5))
@result{} (3 1 1 5 9 5)

(fold-right cons '(q) '(a b c))
@result{} (a b c q)

(fold-right + 0 '(1 2 3) '(4 5 6))
@result{} 21
@end lisp
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe left--folding procedures


@defun {$fold-left/1} @var{combine} @var{nil} @var{ell}
Like @func{fold-left} for a single list argument, but does not validate its arguments.
@end defun


@defun {$fold-left/2} @var{combine} @var{nil} @vari{ell} @varii{ell}
Like @func{fold-left} for two list arguments, but does not validate its arguments.
@end defun


@defun {$fold-left/3} @var{combine} @var{nil} @vari{ell} @varii{ell} @variii{ell}
Like @func{fold-left} for three list arguments, but does not validate its arguments.
@end defun


@defun {$fold-left/list} @var{combine} @var{nil} @var{list-of-lists}
Like @func{fold-left} for any number list operands, but does not validate its arguments.  All the
list operands must be in the @var{list-of-lists}.

@lisp
($fold-left/list
    (lambda (knil item1 item2 item3 item4)
      (list knil item1 item2 item3 item4))
  0
  '((1 2 3 4)
    (5 6 7 8)
    (9 1 2 3)
    (4 5 6 7)))
@result{} ((((0 1 5 9 4) 2 6 1 5) 3 7 2 6) 4 8 3 7)
@end lisp
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe right--folding procedures


@defun {$fold-right/1} @var{combine} @var{nil} @var{ell}
Like @func{fold-right} for a single list argument, but does not validate its arguments.
@end defun


@defun {$fold-right/2} @var{combine} @var{nil} @vari{ell} @varii{ell}
Like @func{fold-right} for two list arguments, but does not validate its arguments.
@end defun


@defun {$fold-right/3} @var{combine} @var{nil} @vari{ell} @varii{ell} @variii{ell}
Like @func{fold-right} for three list arguments, but does not validate its arguments.
@end defun


@defun {$fold-right/list} @var{combine} @var{nil} @var{list-of-lists}
Like @func{fold-right} for any number list operands, but does not validate its arguments.  All the
list operands must be in the @var{list-of-lists}.

@lisp
($fold-right/list
    (lambda (item1 item2 item3 item4 item5 knil)
      (cons (list item1 item2 item3 item4 item5) knil))
  0
  '((1 2 3 4)
    (5 6 7 8)
    (9 1 2 3)
    (4 5 6 7)
    (a b c d)))
@result{} ((1 5 9 4 a) (2 6 1 5 b) (3 7 2 6 c) (4 8 3 7 d) . 0)
@end lisp
@end defun

@c page
@node map
@chapter Mapping lists


@defun map-in-order @var{proc} @vari{list} @varii{list} @dots{}
The @var{list}s must all have the same length.  @var{proc} must accept as many arguments as there
are @var{list}s and return a single value.  @var{proc} must not mutate any of the @var{list}s.

The @func{map-in-order} procedure applies @var{proc} element--wise to the elements of the
@var{list}s, left to right, and returns a list of the results, in order.  @var{proc} is always
called in the same dynamic environment as @func{map-in-order} itself.  If multiple returns occur
from @func{map-in-order}, the values returned by earlier returns are not mutated.

@lisp
(map cadr '((a b) (d e) (g h)))         @result{}  (b e h)

(map (lambda (n) (expt n n))
     '(1 2 3 4 5))                      @result{}  (1 4 27 256 3125)

(map + '(1 2 3) '(4 5 6))               @result{}  (5 7 9)

(let ((count 0))
  (map (lambda (ignored)
         (set! count (+ count 1))
         count)
       '(a b)))                         @result{}  (1 2) or (2 1)
@end lisp
@end defun


@defun for-each-in-order @var{proc} @vari{list} @varii{list} @dots{}
The @var{list}s must all have the same length.  @var{proc} must accept as many arguments as there
are @var{list}s.  @var{proc} must not mutate any of the @var{list}s.

The @func{for-each-in-order} procedure applies @var{proc} element--wise to the elements of the
@var{list}s for its side effects, in order from the first elements to the last.  @var{proc} is
always called in the same dynamic environment as @func{for-each-in-order} itself.  The return values
of @func{for-each-in-order} are unspecified.

@lisp
(let ((v (make-vector 5)))
  (for-each-in-order
      (lambda (i)
        (vector-set! v i (* i i)))
    '(0 1 2 3 4))
  v)
@result{}  #(0 1 4 9 16)

(for-each-in-order (lambda (x) x) '(1 2 3 4))
@result{} unspecified

(for-each-in-order even? '())
@result{} unspecified
@end lisp
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe mapping procedures


@defun {$map/1} @var{func} @var{ell}
Like @func{map} for a single list argument, but does not validate its arguments.
@end defun


@defun {$map/2} @var{func} @vari{ell} @varii{ell}
Like @func{map} for two list arguments, but does not validate its arguments.
@end defun


@defun {$map/3} @var{func} @vari{ell} @varii{ell} @variii{ell}
Like @func{map} for three list arguments, but does not validate its arguments.
@end defun


@defun {$map/list} @var{func} @var{list-of-lists}
Like @func{map} for any number list operands, but does not validate its arguments.  All the list
operands must be in the @var{list-of-lists}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe iteration procedures


@defun {$for-each/1} @var{func} @var{ell}
Like @func{for-each} for a single list argument, but does not validate its arguments.
@end defun


@defun {$for-each/2} @var{func} @vari{ell} @varii{ell}
Like @func{for-each} for two list arguments, but does not validate its arguments.
@end defun


@defun {$for-each/3} @var{func} @vari{ell} @varii{ell} @variii{ell}
Like @func{for-each} for three list arguments, but does not validate its arguments.
@end defun


@defun {$for-each/list} @var{func} @var{list-of-lists}
Like @func{for-each} for any number list operands, but does not validate its arguments.  All the
list operands must be in the @var{list-of-lists}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe in--order mapping procedures


@defun {$map-in-order/1} @var{func} @var{ell}
Like @func{map-in-order} for a single list argument, but does not validate its arguments.
@end defun


@defun {$map-in-order/2} @var{func} @vari{ell} @varii{ell}
Like @func{map-in-order} for two list arguments, but does not validate its arguments.
@end defun


@defun {$map-in-order/3} @var{func} @vari{ell} @varii{ell} @variii{ell}
Like @func{map-in-order} for three list arguments, but does not validate its arguments.
@end defun


@defun {$map-in-order/list} @var{func} @var{list-of-lists}
Like @func{map-in-order} for any number list operands, but does not validate its arguments.  All the
list operands must be in the @var{list-of-lists}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe in--order iteration procedures


@defun {$for-each-in-order/1} @var{func} @var{ell}
Like @func{for-each-in-order} for a single list argument, but does not validate its arguments.
@end defun


@defun {$for-each-in-order/2} @var{func} @vari{ell} @varii{ell}
Like @func{for-each-in-order} for two list arguments, but does not validate its arguments.
@end defun


@defun {$for-each-in-order/3} @var{func} @vari{ell} @varii{ell} @variii{ell}
Like @func{for-each-in-order} for three list arguments, but does not validate its arguments.
@end defun


@defun {$for-each-in-order/list} @var{func} @var{list-of-lists}
Like @func{for-each-in-order} for any number list operands, but does not validate its arguments.
All the list operands must be in the @var{list-of-lists}.
@end defun

@c page
@node search
@chapter Searching lists


@defun find @var{proc} @var{list}
@var{proc} must accept one argument and return a single value.  @var{proc} must not mutate
@var{list}.  The @func{find} procedure applies @var{proc} to the elements of @var{list} in order.
If @var{proc} returns a true value for an element, @func{find} immediately returns that element.  If
@var{proc} returns @false{} for all elements of the list, @func{find} returns @false{}.  @var{proc}
is always called in the same dynamic environment as @func{find} itself.

@lisp
(find even? '(3 1 4 1 5 9))
@result{} 4

(find even? '(3 1 5 1 5 9))
@result{} #f
@end lisp
@end defun


@defun for-all @var{proc} @vari{list} @varii{list} @dots{} @varn{list}
The @var{list}s must all have the same length, and @var{proc} must accept @math{n} arguments and
return a single value.  @var{proc} must not mutate the @var{list} arguments.

For natural numbers @math{i = 0, 1, @dots{}}, the @func{for-all} procedure successively applies
@var{proc} to arguments @math{x_i^1 @dots{} x_i^n}, where @math{x_i^j} is the @math{i}-th element of
@varj{list}, until @false{} is returned.

If @var{proc} returns true values for all but the last element of the @var{list} arguments:
@func{for-all} performs a tail call of @var{proc} on the elements @math{k-1}, where @math{k} is the
length of the lists.  If @var{proc} returns @false{} on any set of elements: @func{for-all} returns
@false{} after the first such application of @var{proc}.  If the @var{list}s are all empty,
@func{for-all} returns @true{}.

@var{proc} is always called in the same dynamic environment as @func{for-all} itself.

@lisp
(for-all even? '(3 1 4 1 5 9))
@result{} #f

(for-all even? '(3 1 4 1 5 9 . 2))
@result{} #f

(for-all even? '(2 4 14))
@result{} #t

(for-all even? '(2 4 14 . 9))
@error{} exception &assertion

(for-all (lambda (n) (and (even? n) n))
         '(2 4 14))
@result{} 14

(for-all < '(1 2 3) '(2 3 4))
@result{} #t

(for-all < '(1 2 4) '(2 3 4))
@result{} #f

@end lisp
@end defun


@defun exists @var{proc} @vari{list} @varii{list} @dots{} @varn{list}
The @var{list}s must all have the same length, and @var{proc} must accept @math{n} arguments and
return a single value.  @var{proc} must not mutate the @var{list} arguments.

For natural numbers @math{i = 0, 1, @dots{}}, the @func{exists} procedure applies @var{proc}
successively to arguments @math{x_i^1 @dots{} x_i^n}, where @math{x_i^j} is the @math{i}-th element
of @var{listj}, until a true value is returned.

If @var{proc} returns @false{} for all but the last elements of the @var{list} arguments:
@func{exists} performs a tail call of @var{proc} on the elements @math{k-1} elements, where @math{k}
is the length of the lists.  If @var{proc} returns a true value on any set of elements,
@func{exists} returns that value after the first such application of @var{proc}.  If the @var{list}s
are all empty, @func{exists} returns @false{}.

@var{proc} is always called in the same dynamic environment as @func{for-all} or, respectively,
@func{exists} itself.

@lisp
(exists even? '(3 1 4 1 5 9))
@result{} #t

(exists even? '(3 1 1 5 9))
@result{} #f

(exists even? '(3 1 1 5 9 . 2))
@error{} exception &assertion

(exists (lambda (n) (and (even? n) n))
        '(2 1 4 14))
@result{} 2

(exists < '(1 2 4) '(2 3 4))
@result{} #t

(exists > '(1 2 3) '(2 3 4))
@result{} #f
@end lisp
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe finding


@defun {$find} @var{pred} @var{ell}
Like @func{find}, but does not validate its arguments.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe searching ``for all'' procedures


@defun {$for-all/1} @var{pred} @var{ell}
Like @func{for-all} for a single list argument, but does not validate its arguments.
@end defun


@defun {$for-all/2} @var{pred} @vari{ell} @varii{ell}
Like @func{for-all} for two list arguments, but does not validate its arguments.
@end defun


@defun {$for-all/3} @var{pred} @vari{ell} @varii{ell} @variii{ell}
Like @func{for-all} for three list arguments, but does not validate its arguments.
@end defun


@defun {$for-all/list} @var{pred} @var{list-of-lists}
Like @func{for-all} for any number list operands, but does not validate its arguments.  All the list
operands must be in the @var{list-of-lists}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Unsafe searching ``exists'' procedures


@defun {$exists/1} @var{pred} @var{ell}
Like @func{exists} for a single list argument, but does not validate its arguments.
@end defun


@defun {$exists/2} @var{pred} @vari{ell} @varii{ell}
Like @func{exists} for two list arguments, but does not validate its arguments.
@end defun


@defun {$exists/3} @var{pred} @vari{ell} @varii{ell} @variii{ell}
Like @func{exists} for three list arguments, but does not validate its arguments.
@end defun


@defun {$exists/list} @var{pred} @var{list-of-lists}
Like @func{exists} for any number list operands, but does not validate its arguments.  All the list
operands must be in the @var{list-of-lists}.
@end defun

@c page
@node conditions
@chapter Exceptional--condition object--types


@menu
* conditions is empty::         Exceptional condition: @condition{list-is-empty}.
* conditions diff len::         Exceptional condition: @condition{lists-are-of-different-length}.
* conditions empty len::        Exceptional condition: @condition{lists-are-empty-or-of-different-length}.
@end menu

@c page
@node conditions is empty
@section Exceptional condition: @condition{list-is-empty}


@deftp {Condition Object} @acondition{list-is-empty}
Exceptional--condition object--type representing an invalid empty list operand: a non--empty proper
list was expected.
@end deftp


@defun make-list-is-empty-condition
Build and return a new exceptional--condition object of type @condition{list-is-empty}.
@end defun


@defun condition-list-is-empty? @var{obj}
Return @true{} if @var{obj} is an exceptional--condition object of type @condition{list-is-empty} or
a compound condition object having a component of type @condition{list-is-empty}; otherwise return
@false{}.
@end defun


@defun raise-exception-list-is-empty @var{who} @var{obj}
Raise a non--continuable exception with compound condition object having components:
@condition{list-is-empty}; @condition{who}; @condition{message}; @condition{irritants}.
@end defun

@c page
@node conditions diff len
@section Exceptional condition: @condition{lists-are-of-different-length}


@deftp {Condition Object} @acondition{lists-are-of-different-length}
Exceptional--condition object--type representing invalid list operands: a proper lists with the same
length were expected.
@end deftp


@defun make-lists-are-of-different-length-condition
Build and return a new exceptional--condition object of type
@condition{lists-are-of-different-length}.
@end defun


@defun condition-lists-are-of-different-length? @var{obj}
Return @true{} if @var{obj} is an exceptional--condition object of type
@condition{lists-are-of-different-length} or a compound condition object having a component of type
@condition{lists-are-of-different-length}; otherwise return @false{}.
@end defun


@defun raise-exception-lists-are-of-different-length @var{who} @var{obj}
Raise a non--continuable exception with compound condition object having components:
@condition{lists-are-of-different-length}; @condition{who}; @condition{message};
@condition{irritants}.
@end defun

@c page
@node conditions empty len
@section Exceptional condition: @condition{lists-are-empty-or-of-different-length}


@deftp {Condition Object} @acondition{lists-are-empty-or-of-different-length}
Exceptional--condition object--type representing invalid list operands: a proper lists with the same
length were expected.
@end deftp


@defun make-lists-are-empty-or-of-different-length-condition
Build and return a new exceptional--condition object of type
@condition{lists-are-empty-or-of-different-length}.
@end defun


@defun condition-lists-are-empty-or-of-different-length? @var{obj}
Return @true{} if @var{obj} is an exceptional--condition object of type
@condition{lists-are-empty-or-of-different-length} or a compound condition object having a component of type
@condition{lists-are-empty-or-of-different-length}; otherwise return @false{}.
@end defun


@defun raise-exception-lists-are-empty-or-of-different-length @var{who} @var{obj}
Raise a non--continuable exception with compound condition object having components:
@condition{lists-are-empty-or-of-different-length}; @condition{who}; @condition{message};
@condition{irritants}.
@end defun

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
@chicken{} can be downloaded from:

@center @url{http://www.call-cc.org/}

@noindent
the package @mmck{} Lang is available from:

@center @url{https://github.com/marcomaggi/mmck-lang/}

@noindent
the package @mmck{} Exceptional Conditions is available from:

@center @url{https://github.com/marcomaggi/mmck-exceptional-conditions/}

@noindent
the package @mmck{} Checks is available from:

@center @url{https://github.com/marcomaggi/mmck-checks/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function

@printindex fn

@node variable index
@appendix An entry for each variable

@printindex vr

@node type index
@appendix An entry for each type

@printindex tp

@contents
@bye

@c end of file
@c Local Variables:
@c ispell-local-dictionary: "en_GB-ise-w_accents"
@c end:
